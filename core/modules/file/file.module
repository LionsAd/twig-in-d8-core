<?php

/**
 * @file
 * Defines a "managed_file" Form API field and a "file" field for Field module.
 */

use Drupal\file\Plugin\Core\Entity\File;
use Drupal\Component\Utility\NestedArray;
use Drupal\Core\Template\Attribute;
use Symfony\Component\HttpFoundation\JsonResponse;
use Drupal\file\FileUsage\DatabaseFileUsageBackend;
use Drupal\file\FileUsage\FileUsageInterface;
use Drupal\Core\Ajax\AjaxResponse;
use Drupal\Core\Ajax\ReplaceCommand;

// Load all Field module hooks for File.
require_once DRUPAL_ROOT . '/core/modules/file/file.field.inc';

/**
 * Implements hook_help().
 */
function file_help($path, $arg) {
  switch ($path) {
    case 'admin/help#file':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The File module defines a <em>File</em> field type for the Field module, which lets you manage and validate uploaded files attached to content on your site (see the <a href="@field-help">Field module help page</a> for more information about fields). For more information, see the online handbook entry for <a href="@file">File module</a>.', array('@field-help' => url('admin/help/field'), '@file' => 'http://drupal.org/documentation/modules/file')) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Attaching files to content') . '</dt>';
      $output .= '<dd>' . t('The File module allows users to attach files to content (e.g., PDF files, spreadsheets, etc.), when a <em>File</em> field is added to a given content type using the <a href="@fieldui-help">Field UI module</a>. You can add validation options to your File field, such as specifying a maximum file size and allowed file extensions.', array('@fieldui-help' => url('admin/help/field_ui'))) . '</dd>';
      $output .= '<dt>' . t('Managing attachment display') . '</dt>';
      $output .= '<dd>' . t('When you attach a file to content, you can specify whether it is <em>listed</em> or not. Listed files are displayed automatically in a section at the bottom of your content; non-listed files are available for embedding in your content, but are not included in the list at the bottom.') . '</dd>';
      $output .= '<dt>' . t('Managing file locations') . '</dt>';
      $output .= '<dd>' . t("When you create a File field, you can specify a directory where the files will be stored, which can be within either the <em>public</em> or <em>private</em> files directory. Files in the public directory can be accessed directly through the web server; when public files are listed, direct links to the files are used, and anyone who knows a file's URL can download the file. Files in the private directory are not accessible directly through the web server; when private files are listed, the links are Drupal path requests. This adds to server load and download time, since Drupal must start up and resolve the path for each file download request, but allows for access restrictions.") . '</dd>';
      $output .= '</dl>';
      return $output;
  }
}

/**
 * Implements hook_menu().
 */
function file_menu() {
  $items = array();

  $items['file/ajax'] = array(
    'page callback' => 'file_ajax_upload',
    'access arguments' => array('access content'),
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
  );
  $items['file/progress'] = array(
    'page callback' => 'file_ajax_progress',
    'access arguments' => array('access content'),
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_element_info().
 *
 * The managed file element may be used anywhere in Drupal.
 */
function file_element_info() {
  $file_path = drupal_get_path('module', 'file');
  $types['managed_file'] = array(
    '#input' => TRUE,
    '#process' => array('file_managed_file_process'),
    '#value_callback' => 'file_managed_file_value',
    '#element_validate' => array('file_managed_file_validate'),
    '#pre_render' => array('file_managed_file_pre_render'),
    '#theme' => 'file_managed_file',
    '#theme_wrappers' => array('form_element'),
    '#progress_indicator' => 'throbber',
    '#progress_message' => NULL,
    '#upload_validators' => array(),
    '#upload_location' => NULL,
    '#size' => 22,
    '#multiple' => FALSE,
    '#extended' => FALSE,
    '#attached' => array(
      'library' => array(array('file','drupal.file')),
    ),
  );
  return $types;
}

/**
 * Implements hook_entity_view_mode_info().
 */
function file_entity_view_mode_info() {
  $view_modes['file']['full'] = array(
    'label' => t('File default'),
  );
  return $view_modes;
}

/**
 * Loads file entities from the database.
 *
 * @param array $fids
 *   (optional) An array of entity IDs. If omitted, all entities are loaded.
 * @param $reset
 *   Whether to reset the internal file_load_multiple() cache.
 *
 * @return array
 *   An array of file entities, indexed by fid.
 *
 * @see hook_file_load()
 * @see file_load()
 * @see entity_load()
 * @see Drupal\Core\Entity\Query\EntityQueryInterface
 */
function file_load_multiple(array $fids = NULL, $reset = FALSE) {
  return entity_load_multiple('file', $fids, $reset);
}

/**
 * Loads a single file entity from the database.
 *
 * @param $fid
 *   A file ID.
 * @param $reset
 *   Whether to reset the internal file_load_multiple() cache.
 *
 * @return Drupal\file\File
 *   A file entity or FALSE if the file was not found.
 *
 * @see hook_file_load()
 * @see file_load_multiple()
 */
function file_load($fid, $reset = FALSE) {
  $files = file_load_multiple(array($fid), $reset);
  return reset($files);
}

/**
 * Returns the file usage service.
 *
 * @return Drupal\file\FileUsage\FileUsageInterface.
 */
function file_usage() {
  return drupal_container()->get('file.usage');
}

/**
 * Copies a file to a new location and adds a file record to the database.
 *
 * This function should be used when manipulating files that have records
 * stored in the database. This is a powerful function that in many ways
 * performs like an advanced version of copy().
 * - Checks if $source and $destination are valid and readable/writable.
 * - Checks that $source is not equal to $destination; if they are an error
 *   is reported.
 * - If file already exists in $destination either the call will error out,
 *   replace the file or rename the file based on the $replace parameter.
 * - Adds the new file to the files database. If the source file is a
 *   temporary file, the resulting file will also be a temporary file. See
 *   file_save_upload() for details on temporary files.
 *
 * @param Drupal\file\File $source
 *   A file entity.
 * @param $destination
 *   A string containing the destination that $source should be copied to.
 *   This must be a stream wrapper URI.
 * @param $replace
 *   Replace behavior when the destination file already exists:
 *   - FILE_EXISTS_REPLACE - Replace the existing file. If a managed file with
 *       the destination name exists then its database entry will be updated. If
 *       no database entry is found then a new one will be created.
 *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is
 *       unique.
 *   - FILE_EXISTS_ERROR - Do nothing and return FALSE.
 *
 * @return
 *   File object if the copy is successful, or FALSE in the event of an error.
 *
 * @see file_unmanaged_copy()
 * @see hook_file_copy()
 */
function file_copy(File $source, $destination = NULL, $replace = FILE_EXISTS_RENAME) {
  if (!file_valid_uri($destination)) {
    if (($realpath = drupal_realpath($source->uri)) !== FALSE) {
      watchdog('file', 'File %file (%realpath) could not be copied because the destination %destination is invalid. This is often caused by improper use of file_copy() or a missing stream wrapper.', array('%file' => $source->uri, '%realpath' => $realpath, '%destination' => $destination));
    }
    else {
      watchdog('file', 'File %file could not be copied because the destination %destination is invalid. This is often caused by improper use of file_copy() or a missing stream wrapper.', array('%file' => $source->uri, '%destination' => $destination));
    }
    drupal_set_message(t('The specified file %file could not be copied because the destination is invalid. More information is available in the system log.', array('%file' => $source->uri)), 'error');
    return FALSE;
  }

  if ($uri = file_unmanaged_copy($source->uri, $destination, $replace)) {
    $file = clone $source;
    $file->fid = NULL;
    $file->uri = $uri;
    $file->filename = drupal_basename($uri);
    // If we are replacing an existing file re-use its database record.
    if ($replace == FILE_EXISTS_REPLACE) {
      $existing_files = entity_load_multiple_by_properties('file', array('uri' => $uri));
      if (count($existing_files)) {
        $existing = reset($existing_files);
        $file->fid = $existing->fid;
        $file->filename = $existing->filename;
      }
    }
    // If we are renaming around an existing file (rather than a directory),
    // use its basename for the filename.
    elseif ($replace == FILE_EXISTS_RENAME && is_file($destination)) {
      $file->filename = drupal_basename($destination);
    }

    $file->save();

    // Inform modules that the file has been copied.
    module_invoke_all('file_copy', $file, $source);

    return $file;
  }
  return FALSE;
}

/**
 * Moves a file to a new location and update the file's database entry.
 *
 * Moving a file is performed by copying the file to the new location and then
 * deleting the original.
 * - Checks if $source and $destination are valid and readable/writable.
 * - Performs a file move if $source is not equal to $destination.
 * - If file already exists in $destination either the call will error out,
 *   replace the file or rename the file based on the $replace parameter.
 * - Adds the new file to the files database.
 *
 * @param Drupal\file\File $source
 *   A file entity.
 * @param $destination
 *   A string containing the destination that $source should be moved to.
 *   This must be a stream wrapper URI.
 * @param $replace
 *   Replace behavior when the destination file already exists:
 *   - FILE_EXISTS_REPLACE - Replace the existing file. If a managed file with
 *       the destination name exists then its database entry will be updated and
 *       $source->delete() called after invoking hook_file_move().
 *       If no database entry is found then the source files record will be
 *       updated.
 *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is
 *       unique.
 *   - FILE_EXISTS_ERROR - Do nothing and return FALSE.
 *
 * @return Drupal\file\File
 *   Resulting file entity for success, or FALSE in the event of an error.
 *
 * @see file_unmanaged_move()
 * @see hook_file_move()
 */
function file_move(File $source, $destination = NULL, $replace = FILE_EXISTS_RENAME) {
  if (!file_valid_uri($destination)) {
    if (($realpath = drupal_realpath($source->uri)) !== FALSE) {
      watchdog('file', 'File %file (%realpath) could not be moved because the destination %destination is invalid. This may be caused by improper use of file_move() or a missing stream wrapper.', array('%file' => $source->uri, '%realpath' => $realpath, '%destination' => $destination));
    }
    else {
      watchdog('file', 'File %file could not be moved because the destination %destination is invalid. This may be caused by improper use of file_move() or a missing stream wrapper.', array('%file' => $source->uri, '%destination' => $destination));
    }
    drupal_set_message(t('The specified file %file could not be moved because the destination is invalid. More information is available in the system log.', array('%file' => $source->uri)), 'error');
    return FALSE;
  }

  if ($uri = file_unmanaged_move($source->uri, $destination, $replace)) {
    $delete_source = FALSE;

    $file = clone $source;
    $file->uri = $uri;
    // If we are replacing an existing file re-use its database record.
    if ($replace == FILE_EXISTS_REPLACE) {
      $existing_files = entity_load_multiple_by_properties('file', array('uri' => $uri));
      if (count($existing_files)) {
        $existing = reset($existing_files);
        $delete_source = TRUE;
        $file->fid = $existing->fid;
      }
    }
    // If we are renaming around an existing file (rather than a directory),
    // use its basename for the filename.
    elseif ($replace == FILE_EXISTS_RENAME && is_file($destination)) {
      $file->filename = drupal_basename($destination);
    }

    $file->save();

    // Inform modules that the file has been moved.
    module_invoke_all('file_move', $file, $source);

    // Delete the original if it's not in use elsewhere.
    if ($delete_source && !file_usage()->listUsage($source)) {
      $source->delete();
    }

    return $file;
  }
  return FALSE;
}

/**
 * Checks that a file meets the criteria specified by the validators.
 *
 * After executing the validator callbacks specified hook_file_validate() will
 * also be called to allow other modules to report errors about the file.
 *
 * @param Drupal\file\File $file
 *   A file entity.
 * @param $validators
 *   An optional, associative array of callback functions used to validate the
 *   file. The keys are function names and the values arrays of callback
 *   parameters which will be passed in after the file entity. The
 *   functions should return an array of error messages; an empty array
 *   indicates that the file passed validation. The functions will be called in
 *   the order specified.
 *
 * @return
 *   An array containing validation error messages.
 *
 * @see hook_file_validate()
 */
function file_validate(File $file, $validators = array()) {
  // Call the validation functions specified by this function's caller.
  $errors = array();
  foreach ($validators as $function => $args) {
    if (function_exists($function)) {
      array_unshift($args, $file);
      $errors = array_merge($errors, call_user_func_array($function, $args));
    }
  }

  // Let other modules perform validation on the new file.
  return array_merge($errors, module_invoke_all('file_validate', $file));
}

/**
 * Checks for files with names longer than can be stored in the database.
 *
 * @param Drupal\file\File $file
 *   A file entity.
 *
 * @return
 *   An array. If the file name is too long, it will contain an error message.
 */
function file_validate_name_length(File $file) {
  $errors = array();

  if (empty($file->filename)) {
    $errors[] = t("The file's name is empty. Please give a name to the file.");
  }
  if (strlen($file->filename) > 240) {
    $errors[] = t("The file's name exceeds the 240 characters limit. Please rename the file and try again.");
  }
  return $errors;
}

/**
 * Checks that the filename ends with an allowed extension.
 *
 * @param Drupal\file\File $file
 *   A file entity.
 * @param $extensions
 *   A string with a space separated list of allowed extensions.
 *
 * @return
 *   An array. If the file extension is not allowed, it will contain an error
 *   message.
 *
 * @see hook_file_validate()
 */
function file_validate_extensions(File $file, $extensions) {
  $errors = array();

  $regex = '/\.(' . preg_replace('/ +/', '|', preg_quote($extensions)) . ')$/i';
  if (!preg_match($regex, $file->filename)) {
    $errors[] = t('Only files with the following extensions are allowed: %files-allowed.', array('%files-allowed' => $extensions));
  }
  return $errors;
}

/**
 * Checks that the file's size is below certain limits.
 *
 * This check is not enforced for the user #1.
 *
 * @param Drupal\file\File $file
 *   A file entity.
 * @param $file_limit
 *   An integer specifying the maximum file size in bytes. Zero indicates that
 *   no limit should be enforced.
 * @param $user_limit
 *   An integer specifying the maximum number of bytes the user is allowed.
 *   Zero indicates that no limit should be enforced.
 *
 * @return
 *   An array. If the file size exceeds limits, it will contain an error
 *   message.
 *
 * @see hook_file_validate()
 */
function file_validate_size(File $file, $file_limit = 0, $user_limit = 0) {
  global $user;
  $errors = array();

  if ($file_limit && $file->filesize > $file_limit) {
    $errors[] = t('The file is %filesize exceeding the maximum file size of %maxsize.', array('%filesize' => format_size($file->filesize), '%maxsize' => format_size($file_limit)));
  }

  // Save a query by only calling spaceUsed() when a limit is provided.
  if ($user_limit && (Drupal::entityManager()->getStorageController('file')->spaceUsed($user->uid) + $file->filesize) > $user_limit) {
    $errors[] = t('The file is %filesize which would exceed your disk quota of %quota.', array('%filesize' => format_size($file->filesize), '%quota' => format_size($user_limit)));
  }

  return $errors;
}

/**
 * Checks that the file is recognized by image_get_info() as an image.
 *
 * @param Drupal\file\File $file
 *   A file entity.
 *
 * @return
 *   An array. If the file is not an image, it will contain an error message.
 *
 * @see hook_file_validate()
 */
function file_validate_is_image(File $file) {
  $errors = array();

  $info = image_get_info($file->uri);
  if (!$info || empty($info['extension'])) {
    $errors[] = t('Only JPEG, PNG and GIF images are allowed.');
  }

  return $errors;
}

/**
 * Verifies that image dimensions are within the specified maximum and minimum.
 *
 * Non-image files will be ignored. If a image toolkit is available the image
 * will be scaled to fit within the desired maximum dimensions.
 *
 * @param Drupal\file\File $file
 *   A file entity. This function may resize the file affecting its size.
 * @param $maximum_dimensions
 *   An optional string in the form WIDTHxHEIGHT e.g. '640x480' or '85x85'. If
 *   an image toolkit is installed the image will be resized down to these
 *   dimensions. A value of 0 indicates no restriction on size, so resizing
 *   will be attempted.
 * @param $minimum_dimensions
 *   An optional string in the form WIDTHxHEIGHT. This will check that the
 *   image meets a minimum size. A value of 0 indicates no restriction.
 *
 * @return
 *   An array. If the file is an image and did not meet the requirements, it
 *   will contain an error message.
 *
 * @see hook_file_validate()
 */
function file_validate_image_resolution(File $file, $maximum_dimensions = 0, $minimum_dimensions = 0) {
  $errors = array();

  // Check first that the file is an image.
  if ($info = image_get_info($file->uri)) {
    if ($maximum_dimensions) {
      // Check that it is smaller than the given dimensions.
      list($width, $height) = explode('x', $maximum_dimensions);
      if ($info['width'] > $width || $info['height'] > $height) {
        // Try to resize the image to fit the dimensions.
        if ($image = image_load($file->uri)) {
          image_scale($image, $width, $height);
          image_save($image);
          $file->filesize = $image->info['file_size'];
          drupal_set_message(t('The image was resized to fit within the maximum allowed dimensions of %dimensions pixels.', array('%dimensions' => $maximum_dimensions)));
        }
        else {
          $errors[] = t('The image is too large; the maximum dimensions are %dimensions pixels.', array('%dimensions' => $maximum_dimensions));
        }
      }
    }

    if ($minimum_dimensions) {
      // Check that it is larger than the given dimensions.
      list($width, $height) = explode('x', $minimum_dimensions);
      if ($info['width'] < $width || $info['height'] < $height) {
        $errors[] = t('The image is too small; the minimum dimensions are %dimensions pixels.', array('%dimensions' => $minimum_dimensions));
      }
    }
  }

  return $errors;
}

/**
 * Saves a file to the specified destination and creates a database entry.
 *
 * @param $data
 *   A string containing the contents of the file.
 * @param $destination
 *   A string containing the destination URI. This must be a stream wrapper URI.
 *   If no value is provided, a randomized name will be generated and the file
 *   will be saved using Drupal's default files scheme, usually "public://".
 * @param $replace
 *   Replace behavior when the destination file already exists:
 *   - FILE_EXISTS_REPLACE - Replace the existing file. If a managed file with
 *       the destination name exists then its database entry will be updated. If
 *       no database entry is found then a new one will be created.
 *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is
 *       unique.
 *   - FILE_EXISTS_ERROR - Do nothing and return FALSE.
 *
 * @return Drupal\file\File
 *   A file entity, or FALSE on error.
 *
 * @see file_unmanaged_save_data()
 */
function file_save_data($data, $destination = NULL, $replace = FILE_EXISTS_RENAME) {
  global $user;

  if (empty($destination)) {
    $destination = file_default_scheme() . '://';
  }
  if (!file_valid_uri($destination)) {
    watchdog('file', 'The data could not be saved because the destination %destination is invalid. This may be caused by improper use of file_save_data() or a missing stream wrapper.', array('%destination' => $destination));
    drupal_set_message(t('The data could not be saved because the destination is invalid. More information is available in the system log.'), 'error');
    return FALSE;
  }

  if ($uri = file_unmanaged_save_data($data, $destination, $replace)) {
    // Create a file entity.
    $file = entity_create('file', array(
      'uri' => $uri,
      'uid' => $user->uid,
      'status' => FILE_STATUS_PERMANENT,
    ));
    // If we are replacing an existing file re-use its database record.
    if ($replace == FILE_EXISTS_REPLACE) {
      $existing_files = entity_load_multiple_by_properties('file', array('uri' => $uri));
      if (count($existing_files)) {
        $existing = reset($existing_files);
        $file->fid = $existing->fid;
        $file->filename = $existing->filename;
      }
    }
    // If we are renaming around an existing file (rather than a directory),
    // use its basename for the filename.
    elseif ($replace == FILE_EXISTS_RENAME && is_file($destination)) {
      $file->filename = drupal_basename($destination);
    }

    $file->save();
    return $file;
  }
  return FALSE;
}

/**
 * Examines a file entity and returns appropriate content headers for download.
 *
 * @param Drupal\file\File $file
 *   A file entity.
 *
 * @return
 *   An associative array of headers, as expected by
 *   \Symfony\Component\HttpFoundation\StreamedResponse.
 */
function file_get_content_headers(File $file) {
  $name = mime_header_encode($file->filename);
  $type = mime_header_encode($file->filemime);

  return array(
    'Content-Type' => $type,
    'Content-Length' => $file->filesize,
    'Cache-Control' => 'private',
  );
}

/**
 * Implements hook_theme().
 */
function file_theme() {
  return array(
    // From file.module.
    'file_link' => array(
      'variables' => array('file' => NULL, 'icon_directory' => NULL, 'description' => NULL),
      'template' => 'file-link',
    ),
    'file_managed_file' => array(
      'render element' => 'element',
      'template' => 'file-managed-file',
    ),

    // From file.field.inc.
    'file_widget' => array(
      'render element' => 'element',
      'template' => 'file-widget',
    ),
    'file_widget_multiple' => array(
      'render element' => 'element',
      'template' => 'file-widget-multiple'
    ),
    'file_formatter_table' => array(
      'variables' => array('items' => NULL),
      'template' => 'file-formatter-table',
    ),
    'file_upload_help' => array(
      'variables' => array('description' => NULL, 'upload_validators' => NULL, 'cardinality' => NULL),
      'template' => 'file-upload-help',
    ),
  );
}

/**
 * Implements hook_file_download().
 *
 * This function takes an extra parameter $field_type so that it may
 * be re-used by other File-like modules, such as Image.
 */
function file_file_download($uri, $field_type = 'file') {
  global $user;

  // Get the file record based on the URI. If not in the database just return.
  $files = entity_load_multiple_by_properties('file', array('uri' => $uri));
  if (count($files)) {
    foreach ($files as $item) {
      // Since some database servers sometimes use a case-insensitive comparison
      // by default, double check that the filename is an exact match.
      if ($item->uri === $uri) {
        $file = $item;
        break;
      }
    }
  }
  if (!isset($file)) {
    return;
  }

  // Find out which (if any) fields of this type contain the file.
  $references = file_get_file_references($file, NULL, FIELD_LOAD_CURRENT, $field_type);

  // Stop processing if there are no references in order to avoid returning
  // headers for files controlled by other modules. Make an exception for
  // temporary files where the host entity has not yet been saved (for example,
  // an image preview on a node/add form) in which case, allow download by the
  // file's owner.
  if (empty($references) && ($file->status == FILE_STATUS_PERMANENT || $file->uid != $user->uid)) {
    return;
  }

  // Default to allow access.
  $denied = FALSE;
  // Loop through all references of this file. If a reference explicitly allows
  // access to the field to which this file belongs, no further checks are done
  // and download access is granted. If a reference denies access, eventually
  // existing additional references are checked. If all references were checked
  // and no reference denied access, access is granted as well. If at least one
  // reference denied access, access is denied.
  foreach ($references as $field_name => $field_references) {
    foreach ($field_references as $entity_type => $entities) {
      foreach ($entities as $entity) {
        $field = field_info_field($field_name);
        // Check if access to this field is not disallowed.
        if (!field_access('view', $field, $entity_type, $entity)) {
          $denied = TRUE;
          continue;
        }

        // Invoke hook and collect grants/denies for download access.
        // Default to FALSE and let entities overrule this ruling.
        $grants = array('system' => FALSE);
        foreach (module_implements('file_download_access') as $module) {
          $grants = array_merge($grants, array($module => module_invoke($module, 'file_download_access', $field, $entity, $file)));
        }
        // Allow other modules to alter the returned grants/denies.
        $context = array(
          'entity' => $entity,
          'field' => $field,
          'file' => $file,
        );
        drupal_alter('file_download_access', $grants, $context);

        if (in_array(TRUE, $grants)) {
          // If TRUE is returned, access is granted and no further checks are
          // necessary.
          $denied = FALSE;
          break 3;
        }

        if (in_array(FALSE, $grants)) {
          // If an implementation returns FALSE, access to this entity is denied
          // but the file could belong to another entity to which the user might
          // have access. Continue with these.
          $denied = TRUE;
        }
      }
    }
  }

  // Access specifically denied.
  if ($denied) {
    return -1;
  }

  // Access is granted.
  $headers = file_get_content_headers($file);
  return $headers;
}

/**
 * Implements file_cron()
 */
function file_cron() {
  $result = Drupal::entityManager()->getStorageController('file')->retrieveTemporaryFiles();
  foreach ($result as $row) {
    if ($file = file_load($row->fid)) {
      $references = file_usage()->listUsage($file);
      if (empty($references)) {
        if (file_exists($file->uri)) {
          $file->delete();
        }
        else {
          watchdog('file system', 'Could not delete temporary file "%path" during garbage collection', array('%path' => $file->uri), WATCHDOG_ERROR);
        }
      }
      else {
        watchdog('file system', 'Did not delete temporary file "%path" during garbage collection because it is in use by the following modules: %modules.', array('%path' => $file->uri, '%modules' => implode(', ', array_keys($references))), WATCHDOG_INFO);
      }
    }
  }
}

/**
 * Ajax callback: Processes file uploads and deletions.
 *
 * This rebuilds the form element for a particular field item. As long as the
 * form processing is properly encapsulated in the widget element the form
 * should rebuild correctly using FAPI without the need for additional callbacks
 * or processing.
 *
 * @see file_menu()
 */
function file_ajax_upload() {
  $form_parents = func_get_args();
  $form_build_id = (string) array_pop($form_parents);

  if (empty($_POST['form_build_id']) || $form_build_id != $_POST['form_build_id']) {
    // Invalid request.
    drupal_set_message(t('An unrecoverable error occurred. The uploaded file likely exceeded the maximum file size (@size) that this server supports.', array('@size' => format_size(file_upload_max_size()))), 'error');
    $response = new AjaxResponse();
    return $response->addCommand(new ReplaceCommand(NULL, theme('status_messages')));
  }

  list($form, $form_state) = ajax_get_form();

  if (!$form) {
    // Invalid form_build_id.
    drupal_set_message(t('An unrecoverable error occurred. Use of this form has expired. Try reloading the page and submitting again.'), 'error');
    $response = new AjaxResponse();
    return $response->addCommand(new ReplaceCommand(NULL, theme('status_messages')));
  }

  // Get the current element and count the number of files.
  $current_element = $form;
  foreach ($form_parents as $parent) {
    $current_element = $current_element[$parent];
  }
  $current_file_count = isset($current_element['#file_upload_delta']) ? $current_element['#file_upload_delta'] : 0;

  // Process user input. $form and $form_state are modified in the process.
  drupal_process_form($form['#form_id'], $form, $form_state);

  // Retrieve the element to be rendered.
  foreach ($form_parents as $parent) {
    $form = $form[$parent];
  }

  // Add the special Ajax class if a new file was added.
  if (isset($form['#file_upload_delta']) && $current_file_count < $form['#file_upload_delta']) {
    $form[$current_file_count]['#attributes']['class'][] = 'ajax-new-content';
  }
  // Otherwise just add the new content class on a placeholder.
  else {
    $form['#suffix'] .= '<span class="ajax-new-content"></span>';
  }

  $output = theme('status_messages') . drupal_render($form);
  $js = drupal_add_js();
  $settings = drupal_merge_js_settings($js['settings']['data']);

  $response = new AjaxResponse();
  return $response->addCommand(new ReplaceCommand(NULL, $output, $settings));
}

/**
 * Ajax callback: Retrieves upload progress.
 *
 * @param $key
 *   The unique key for this upload process.
 */
function file_ajax_progress($key) {
  $progress = array(
    'message' => t('Starting upload...'),
    'percentage' => -1,
  );

  $implementation = file_progress_implementation();
  if ($implementation == 'uploadprogress') {
    $status = uploadprogress_get_info($key);
    if (isset($status['bytes_uploaded']) && !empty($status['bytes_total'])) {
      $progress['message'] = t('Uploading... (@current of @total)', array('@current' => format_size($status['bytes_uploaded']), '@total' => format_size($status['bytes_total'])));
      $progress['percentage'] = round(100 * $status['bytes_uploaded'] / $status['bytes_total']);
    }
  }
  elseif ($implementation == 'apc') {
    $status = apc_fetch('upload_' . $key);
    if (isset($status['current']) && !empty($status['total'])) {
      $progress['message'] = t('Uploading... (@current of @total)', array('@current' => format_size($status['current']), '@total' => format_size($status['total'])));
      $progress['percentage'] = round(100 * $status['current'] / $status['total']);
    }
  }

  return new JsonResponse($progress);
}

/**
 * Determines the preferred upload progress implementation.
 *
 * @return
 *   A string indicating which upload progress system is available. Either "apc"
 *   or "uploadprogress". If neither are available, returns FALSE.
 */
function file_progress_implementation() {
  static $implementation;
  if (!isset($implementation)) {
    $implementation = FALSE;

    // We prefer the PECL extension uploadprogress because it supports multiple
    // simultaneous uploads. APC only supports one at a time.
    if (extension_loaded('uploadprogress')) {
      $implementation = 'uploadprogress';
    }
    elseif (extension_loaded('apc') && ini_get('apc.rfc1867')) {
      $implementation = 'apc';
    }
  }
  return $implementation;
}

/**
 * Implements hook_file_predelete().
 */
function file_file_predelete(File $file) {
  // TODO: Remove references to a file that is in-use.
}

/**
 * Render API callback: Expands the managed_file element type.
 *
 * Expands the file type to include Upload and Remove buttons, as well as
 * support for a default value.
 *
 * This function is assigned as a #process callback in file_element_info().
 */
function file_managed_file_process($element, &$form_state, $form) {
  // Append the '-upload' to the #id so the field label's 'for' attribute
  // corresponds with the file element.
  $element['#id'] .= '-upload';

  // This is used sometimes so let's implode it just once.
  $parents_prefix = implode('_', $element['#parents']);

  $fids = isset($element['#value']['fids']) ? $element['#value']['fids'] : array();

  // Set some default element properties.
  $element['#progress_indicator'] = empty($element['#progress_indicator']) ? 'none' : $element['#progress_indicator'];
  $element['#files'] = !empty($fids) ? file_load_multiple($fids) : FALSE;
  $element['#tree'] = TRUE;

  $ajax_settings = array(
    'path' => 'file/ajax/' . implode('/', $element['#array_parents']) . '/' . $form['form_build_id']['#value'],
    'wrapper' => $element['#id'] . '-ajax-wrapper',
    'effect' => 'fade',
    'progress' => array(
      'type' => $element['#progress_indicator'],
      'message' => $element['#progress_message'],
    ),
  );

  // Set up the buttons first since we need to check if they were clicked.
  $element['upload_button'] = array(
    '#name' => $parents_prefix . '_upload_button',
    '#type' => 'submit',
    '#value' => t('Upload'),
    '#validate' => array(),
    '#submit' => array('file_managed_file_submit'),
    '#limit_validation_errors' => array($element['#parents']),
    '#ajax' => $ajax_settings,
    '#weight' => -5,
  );

  // Force the progress indicator for the remove button to be either 'none' or
  // 'throbber', even if the upload button is using something else.
  $ajax_settings['progress']['type'] = ($element['#progress_indicator'] == 'none') ? 'none' : 'throbber';
  $ajax_settings['progress']['message'] = NULL;
  $ajax_settings['effect'] = 'none';
  $element['remove_button'] = array(
    '#name' => $parents_prefix . '_remove_button',
    '#type' => 'submit',
    '#value' => $element['#multiple'] ? t('Remove selected') : t('Remove'),
    '#validate' => array(),
    '#submit' => array('file_managed_file_submit'),
    '#limit_validation_errors' => array($element['#parents']),
    '#ajax' => $ajax_settings,
    '#weight' => 1,
  );

  $element['fids'] = array(
    '#type' => 'hidden',
    '#value' => $fids,
  );

  // Add progress bar support to the upload if possible.
  if ($element['#progress_indicator'] == 'bar' && $implementation = file_progress_implementation()) {
    $upload_progress_key = mt_rand();

    if ($implementation == 'uploadprogress') {
      $element['UPLOAD_IDENTIFIER'] = array(
        '#type' => 'hidden',
        '#value' => $upload_progress_key,
        '#attributes' => array('class' => array('file-progress')),
        // Uploadprogress extension requires this field to be at the top of the
        // form.
        '#weight' => -20,
      );
    }
    elseif ($implementation == 'apc') {
      $element['APC_UPLOAD_PROGRESS'] = array(
        '#type' => 'hidden',
        '#value' => $upload_progress_key,
        '#attributes' => array('class' => array('file-progress')),
        // Uploadprogress extension requires this field to be at the top of the
        // form.
        '#weight' => -20,
      );
    }

    // Add the upload progress callback.
    $element['upload_button']['#ajax']['progress']['path'] = 'file/progress/' . $upload_progress_key;
  }

  // The file upload field itself.
  $element['upload'] = array(
    '#name' => 'files[' . $parents_prefix . ']',
    '#type' => 'file',
    '#title' => t('Choose a file'),
    '#title_display' => 'invisible',
    '#size' => $element['#size'],
    '#multiple' => $element['#multiple'],
    '#theme_wrappers' => array(),
    '#weight' => -10,
  );

  if (!empty($fids) && $element['#files']) {
    foreach ($element['#files'] as $delta => $file) {
      if ($element['#multiple']) {
        $element['file_' . $delta]['selected'] = array(
          '#type' => 'checkbox',
          '#title' => theme('file_link', array('file' => $file)) . ' ',
        );
      }
      else {
        $element['file_' . $delta]['filename'] = array(
          '#type' => 'markup',
          '#markup' => theme('file_link', array('file' => $file)) . ' ',
          '#weight' => -10,
        );
      }
    }
  }

  // Add the extension list to the page as JavaScript settings.
  if (isset($element['#upload_validators']['file_validate_extensions'][0])) {
    $extension_list = implode(',', array_filter(explode(' ', $element['#upload_validators']['file_validate_extensions'][0])));
    $element['upload']['#attached']['js'] = array(
      array(
        'type' => 'setting',
        'data' => array('file' => array('elements' => array('#' . $element['#id'] . '-upload' => $extension_list)))
      )
    );
  }

  // Prefix and suffix used for Ajax replacement.
  $element['#prefix'] = '<div id="' . $element['#id'] . '-ajax-wrapper">';
  $element['#suffix'] = '</div>';

  return $element;
}

/**
 * Render API callback: Determines the value for a managed_file type element.
 *
 * This function is assigned as a #value_callback in file_element_info().
 */
function file_managed_file_value(&$element, $input = FALSE, $form_state = NULL) {
  // Find the current value of this field.
  $fids = !empty($input['fids']) ? explode(' ', $input['fids']) : array();
  foreach ($fids as $key => $fid) {
    $fids[$key] = (int) $fid;
  }

  // Process any input and save new uploads.
  if ($input !== FALSE) {
    $input['fids'] = $fids;
    $return = $input;

    // Uploads take priority over all other values.
    if ($files = file_managed_file_save_upload($element)) {
      if ($element['#multiple']) {
        $fids = array_merge($fids, array_keys($files));
      }
      else {
        $fids = array_keys($files);
      }
    }
    else {
      // Check for #filefield_value_callback values.
      // Because FAPI does not allow multiple #value_callback values like it
      // does for #element_validate and #process, this fills the missing
      // functionality to allow File fields to be extended through FAPI.
      if (isset($element['#file_value_callbacks'])) {
        foreach ($element['#file_value_callbacks'] as $callback) {
          $callback($element, $input, $form_state);
        }
      }

      // Load files if the FIDs have changed to confirm they exist.
      if (!empty($input['fids'])) {
        $fids = array();
        foreach ($input['fids'] as $key => $fid) {
          if ($file = file_load($fid)) {
            $fids[] = $file->fid;
          }
        }
      }
    }
  }

  // If there is no input, set the default value.
  else {
    if ($element['#extended']) {
      $default_fids = isset($element['#default_value']['fids']) ? $element['#default_value']['fids'] : array();
      $return = isset($element['#default_value']) ? $element['#default_value'] : array('fids' => array());
    }
    else {
      $default_fids = isset($element['#default_value']) ? $element['#default_value'] : array();
      $return = array('fids' => array());
    }

    // Confirm that the file exists when used as a default value.
    if (!empty($default_fids)) {
      $fids = array();
      foreach ($default_fids as $key => $fid) {
        if ($file = file_load($fid)) {
          $fids[] = $file->fid;
        }
      }
    }
  }

  $return['fids'] = $fids;
  return $return;
}

/**
 * Render API callback: Validates the managed_file element.
 *
 * This function is assigned as a #element_validate callback in
 * file_element_info().
 */
function file_managed_file_validate(&$element, &$form_state) {
  // If referencing an existing file, only allow if there are existing
  // references. This prevents unmanaged files from being deleted if this
  // item were to be deleted.
  $clicked_button = end($form_state['triggering_element']['#parents']);
  if ($clicked_button != 'remove_button' && !empty($element['fids']['#value'])) {
    $fids = $element['fids']['#value'];
    foreach ($fids as $fid) {
      if ($file = file_load($fid)) {
        if ($file->status == FILE_STATUS_PERMANENT) {
          $references = file_usage()->listUsage($file);
          if (empty($references)) {
            form_error($element, t('The file used in the !name field may not be referenced.', array('!name' => $element['#title'])));
          }
        }
      }
      else {
        form_error($element, t('The file referenced by the !name field does not exist.', array('!name' => $element['#title'])));
      }
    }
  }

  // Check required property based on the FID.
  if ($element['#required'] && empty($element['fids']['#value']) && !in_array($clicked_button, array('upload_button', 'remove_button'))) {
    form_error($element['upload'], t('!name field is required.', array('!name' => $element['#title'])));
  }

  // Consolidate the array value of this field to array of FIDs.
  if (!$element['#extended']) {
    form_set_value($element, $element['fids']['#value'], $form_state);
  }
}

/**
 * Form submission handler for upload / remove buttons of managed_file elements.
 *
 * @see file_managed_file_process()
 */
function file_managed_file_submit($form, &$form_state) {
  // Determine whether it was the upload or the remove button that was clicked,
  // and set $element to the managed_file element that contains that button.
  $parents = $form_state['triggering_element']['#array_parents'];
  $button_key = array_pop($parents);
  $element = NestedArray::getValue($form, $parents);

  // No action is needed here for the upload button, because all file uploads on
  // the form are processed by file_managed_file_value() regardless of which
  // button was clicked. Action is needed here for the remove button, because we
  // only remove a file in response to its remove button being clicked.
  if ($button_key == 'remove_button') {
    $fids = array_keys($element['#files']);
    // Get files that will be removed.
    if ($element['#multiple']) {
      $remove_fids = array();
      foreach (element_children($element) as $name) {
        if (strpos($name, 'file_') === 0 && $element[$name]['selected']['#value']) {
          $remove_fids[] = (int) substr($name, 5);
        }
      }
      $fids = array_diff($fids, $remove_fids);
    }
    else {
      $remove_fids = $fids;
    }

    foreach ($remove_fids as $fid) {
      // If it's a temporary file we can safely remove it immediately, otherwise
      // it's up to the implementing module to remove usages of files to have them
      // removed.
      if ($element['#files'][$fid] && $element['#files'][$fid]->status == 0) {
        file_delete($element['#files'][$fid]->fid);
      }
    }
    // Update both $form_state['values'] and $form_state['input'] to reflect
    // that the file has been removed, so that the form is rebuilt correctly.
    // $form_state['values'] must be updated in case additional submit handlers
    // run, and for form building functions that run during the rebuild, such as
    // when the managed_file element is part of a field widget.
    // $form_state['input'] must be updated so that file_managed_file_value()
    // has correct information during the rebuild.
    form_set_value($element['fids'], implode(' ', $fids), $form_state);
    NestedArray::setValue($form_state['input'], $element['fids']['#parents'], implode(' ', $fids));
  }

  // Set the form to rebuild so that $form is correctly updated in response to
  // processing the file removal. Since this function did not change $form_state
  // if the upload button was clicked, a rebuild isn't necessary in that
  // situation and setting $form_state['redirect'] to FALSE would suffice.
  // However, we choose to always rebuild, to keep the form processing workflow
  // consistent between the two buttons.
  $form_state['rebuild'] = TRUE;
}

/**
 * Saves any files that have been uploaded into a managed_file element.
 *
 * @param $element
 *   The FAPI element whose values are being saved.
 *
 * @return
 *   An array of file entities for each file that was saved, keyed by its file
 *   ID, or FALSE if no files were saved.
 */
function file_managed_file_save_upload($element) {
  $upload_name = implode('_', $element['#parents']);
  if (empty($_FILES['files']['name'][$upload_name])) {
    return FALSE;
  }

  $destination = isset($element['#upload_location']) ? $element['#upload_location'] : NULL;
  if (isset($destination) && !file_prepare_directory($destination, FILE_CREATE_DIRECTORY)) {
    watchdog('file', 'The upload directory %directory for the file field !name could not be created or is not accessible. A newly uploaded file could not be saved in this directory as a consequence, and the upload was canceled.', array('%directory' => $destination, '!name' => $element['#field_name']));
    form_set_error($upload_name, t('The file could not be uploaded.'));
    return FALSE;
  }

  // Save attached files to the database.
  $files_uploaded = $element['#multiple'] && count(array_filter($_FILES['files']['name'][$upload_name])) > 0;
  $files_uploaded |= !$element['#multiple'] && !empty($_FILES['files']['name'][$upload_name]);
  if ($files_uploaded) {
    if (!$files = file_save_upload($upload_name, $element['#upload_validators'], $destination)) {
      watchdog('file', 'The file upload failed. %upload', array('%upload' => $upload_name));
      form_set_error($upload_name, t('Files in the !name field were unable to be uploaded.', array('!name' => $element['#title'])));
      return array();
    }

    // Value callback expects FIDs to be keys.
    $files = array_filter($files);
    $fids = array_map(function($file) { return $file->fid; }, $files);

    return empty($files) ? array() : array_combine($fids, $files);
  }

  return array();
}

/**
 * Prepares variables for file form widget templates.
 *
 * Default template: file-managed-file.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: A render element representing the file.
 *   - element_attributes: An Array of HTML attributes.
 */
function template_preprocess_file_managed_file(&$variables) {
  $element = $variables['element'];

  $attributes = array();
  if (isset($element['#id'])) {
    $attributes['id'] = $element['#id'];
  }
  if (!empty($element['#attributes']['class'])) {
    $attributes['class'] = (array) $element['#attributes']['class'];
  }
  $attributes['class'][] = 'form-managed-file';

  $variables['attributes'] = new Attribute($attributes);
  $variables['element'] = drupal_render_children($element);
}

/**
 * Render API callback: Hides display of the upload or remove controls.
 *
 * Upload controls are hidden when a file is already uploaded. Remove controls
 * are hidden when there is no file attached. Controls are hidden here instead
 * of in file_managed_file_process(), because #access for these buttons depends
 * on the managed_file element's #value. See the documentation of form_builder()
 * for more detailed information about the relationship between #process,
 * #value, and #access.
 *
 * Because #access is set here, it affects display only and does not prevent
 * JavaScript or other untrusted code from submitting the form as though access
 * were enabled. The form processing functions for these elements should not
 * assume that the buttons can't be "clicked" just because they are not
 * displayed.
 *
 * This function is assigned as a #pre_render callback in file_element_info().
 *
 * @see file_managed_file_process()
 * @see form_builder()
 */
function file_managed_file_pre_render($element) {
  // If we already have a file, we don't want to show the upload controls.
  if (!empty($element['#value']['fids'])) {
    if (!$element['#multiple']) {
      $element['upload']['#access'] = FALSE;
      $element['upload_button']['#access'] = FALSE;
    }
  }
  // If we don't already have a file, there is nothing to remove.
  else {
    $element['remove_button']['#access'] = FALSE;
  }
  return $element;
}

/**
 * Prepares variables for file link templates.
 *
 * Default template: file-link.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - file: A file object to which the link will be created.
 *   - icon_directory: (optional) A path to a directory of icons to be used for
 *     files. Defaults to the value of the "icon.directory" variable.
 *   - description: A description to be displayed instead of the filename.
 */
function template_preprocess_file_link(&$variables) {
  $file = $variables['file'];
  $icon_directory = $variables['icon_directory'];

  $url = file_create_url($file->uri);
  $file_entity = ($file instanceof File) ? $file : file_load($file->fid);
  $variables['icon'] = array(
    '#theme' => 'image__file_icon',
    '#uri' => file_icon_url($file_entity, $icon_directory),
    '#alt' => '',
    '#title' => check_plain($file_entity->filename),
    '#attributes' => new Attribute(array('class' => 'file-icon')),
  );

  // Set options as per anchor format described at
  // http://microformats.org/wiki/file-format-examples
  $options = array(
    'attributes' => array(
      'type' => $file->filemime . '; length=' . $file->filesize,
    ),
  );

  // Use the description as the link text if available.
  if (empty($variables['description'])) {
    $link_text = $file->filename;
  }
  else {
    $link_text = $variables['description'];
    $options['attributes']['title'] = check_plain($file->filename);
  }

  $variables['link'] = l($link_text, $url, $options);
  $variables['attributes'] = new Attribute(array('class' => array('file')));
}

/**
 * Creates a URL to the icon for a file entity.
 *
 * @param Drupal\file\File $file
 *   A file entity.
 * @param $icon_directory
 *   (optional) A path to a directory of icons to be used for files. Defaults to
 *   the value of the "icon.directory" variable.
 *
 * @return
 *   A URL string to the icon, or FALSE if an appropriate icon cannot be found.
 */
function file_icon_url(File $file, $icon_directory = NULL) {
  if ($icon_path = file_icon_path($file, $icon_directory)) {
    return base_path() . $icon_path;
  }
  return FALSE;
}

/**
 * Creates a path to the icon for a file entity.
 *
 * @param Drupal\file\File $file
 *   A file entity.
 * @param $icon_directory
 *   (optional) A path to a directory of icons to be used for files. Defaults to
 *   the value of the "icon.directory" variable.
 *
 * @return
 *   A string to the icon as a local path, or FALSE if an appropriate icon could
 *   not be found.
 */
function file_icon_path(File $file, $icon_directory = NULL) {
  // Use the default set of icons if none specified.
  if (!isset($icon_directory)) {
    $icon_directory = config('file.settings')->get('icon.directory');
  }

  // If there's an icon matching the exact mimetype, go for it.
  $dashed_mime = strtr($file->filemime, array('/' => '-'));
  $icon_path = $icon_directory . '/' . $dashed_mime . '.png';
  if (file_exists($icon_path)) {
    return $icon_path;
  }

  // For a few mimetypes, we can "manually" map to a generic icon.
  $generic_mime = (string) file_icon_map($file);
  $icon_path = $icon_directory . '/' . $generic_mime . '.png';
  if ($generic_mime && file_exists($icon_path)) {
    return $icon_path;
  }

  // Use generic icons for each category that provides such icons.
  foreach (array('audio', 'image', 'text', 'video') as $category) {
    if (strpos($file->filemime, $category . '/') === 0) {
      $icon_path = $icon_directory . '/' . $category . '-x-generic.png';
      if (file_exists($icon_path)) {
        return $icon_path;
      }
    }
  }

  // Try application-octet-stream as last fallback.
  $icon_path = $icon_directory . '/application-octet-stream.png';
  if (file_exists($icon_path)) {
    return $icon_path;
  }

  // No icon can be found.
  return FALSE;
}

/**
 * Determines the generic icon MIME package based on a file's MIME type.
 *
 * @param Drupal\file\File $file
 *   A file entity.
 *
 * @return
 *   The generic icon MIME package expected for this file.
 */
function file_icon_map(File $file) {
  switch ($file->filemime) {
    // Word document types.
    case 'application/msword':
    case 'application/vnd.ms-word.document.macroEnabled.12':
    case 'application/vnd.oasis.opendocument.text':
    case 'application/vnd.oasis.opendocument.text-template':
    case 'application/vnd.oasis.opendocument.text-master':
    case 'application/vnd.oasis.opendocument.text-web':
    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
    case 'application/vnd.stardivision.writer':
    case 'application/vnd.sun.xml.writer':
    case 'application/vnd.sun.xml.writer.template':
    case 'application/vnd.sun.xml.writer.global':
    case 'application/vnd.wordperfect':
    case 'application/x-abiword':
    case 'application/x-applix-word':
    case 'application/x-kword':
    case 'application/x-kword-crypt':
      return 'x-office-document';

    // Spreadsheet document types.
    case 'application/vnd.ms-excel':
    case 'application/vnd.ms-excel.sheet.macroEnabled.12':
    case 'application/vnd.oasis.opendocument.spreadsheet':
    case 'application/vnd.oasis.opendocument.spreadsheet-template':
    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
    case 'application/vnd.stardivision.calc':
    case 'application/vnd.sun.xml.calc':
    case 'application/vnd.sun.xml.calc.template':
    case 'application/vnd.lotus-1-2-3':
    case 'application/x-applix-spreadsheet':
    case 'application/x-gnumeric':
    case 'application/x-kspread':
    case 'application/x-kspread-crypt':
      return 'x-office-spreadsheet';

    // Presentation document types.
    case 'application/vnd.ms-powerpoint':
    case 'application/vnd.ms-powerpoint.presentation.macroEnabled.12':
    case 'application/vnd.oasis.opendocument.presentation':
    case 'application/vnd.oasis.opendocument.presentation-template':
    case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
    case 'application/vnd.stardivision.impress':
    case 'application/vnd.sun.xml.impress':
    case 'application/vnd.sun.xml.impress.template':
    case 'application/x-kpresenter':
      return 'x-office-presentation';

    // Compressed archive types.
    case 'application/zip':
    case 'application/x-zip':
    case 'application/stuffit':
    case 'application/x-stuffit':
    case 'application/x-7z-compressed':
    case 'application/x-ace':
    case 'application/x-arj':
    case 'application/x-bzip':
    case 'application/x-bzip-compressed-tar':
    case 'application/x-compress':
    case 'application/x-compressed-tar':
    case 'application/x-cpio-compressed':
    case 'application/x-deb':
    case 'application/x-gzip':
    case 'application/x-java-archive':
    case 'application/x-lha':
    case 'application/x-lhz':
    case 'application/x-lzop':
    case 'application/x-rar':
    case 'application/x-rpm':
    case 'application/x-tzo':
    case 'application/x-tar':
    case 'application/x-tarz':
    case 'application/x-tgz':
      return 'package-x-generic';

    // Script file types.
    case 'application/ecmascript':
    case 'application/javascript':
    case 'application/mathematica':
    case 'application/vnd.mozilla.xul+xml':
    case 'application/x-asp':
    case 'application/x-awk':
    case 'application/x-cgi':
    case 'application/x-csh':
    case 'application/x-m4':
    case 'application/x-perl':
    case 'application/x-php':
    case 'application/x-ruby':
    case 'application/x-shellscript':
    case 'text/vnd.wap.wmlscript':
    case 'text/x-emacs-lisp':
    case 'text/x-haskell':
    case 'text/x-literate-haskell':
    case 'text/x-lua':
    case 'text/x-makefile':
    case 'text/x-matlab':
    case 'text/x-python':
    case 'text/x-sql':
    case 'text/x-tcl':
      return 'text-x-script';

    // HTML aliases.
    case 'application/xhtml+xml':
      return 'text-html';

    // Executable types.
    case 'application/x-macbinary':
    case 'application/x-ms-dos-executable':
    case 'application/x-pef-executable':
      return 'application-x-executable';

    default:
      return FALSE;
  }
}

/**
 * @defgroup file-module-api File module public API functions
 * @{
 * These functions may be used to determine if and where a file is in use.
 */

/**
 * Retrieves a list of references to a file.
 *
 * @param Drupal\file\File $file
 *   A file entity.
 * @param $field
 *   (optional) A field array to be used for this check. If given, limits the
 *   reference check to the given field.
 * @param $age
 *   (optional) A constant that specifies which references to count. Use
 *   FIELD_LOAD_REVISION to retrieve all references within all revisions or
 *   FIELD_LOAD_CURRENT to retrieve references only in the current revisions.
 * @param $field_type
 *   (optional) The name of a field type. If given, limits the reference check
 *   to fields of the given type. If both $field and $field_type is given but
 *   $field is not the same type as $field_type, an empty array will be
 *   returned.
 *
 * @return
 *   A multidimensional array. The keys are field_name, entity_type,
 *   entity_id and the value is an entity referencing this file.
 */
function file_get_file_references(File $file, $field = NULL, $age = FIELD_LOAD_REVISION, $field_type = 'file') {
  $references = &drupal_static(__FUNCTION__, array());
  $field_columns = &drupal_static(__FUNCTION__ . ':field_columns', array());

  // Fill the static cache, disregard $field and $field_type for now.
  if (!isset($references[$file->fid][$age])) {
    $references[$file->fid][$age] = array();
    $usage_list = file_usage()->listUsage($file);
    $file_usage_list = isset($usage_list['file']) ? $usage_list['file'] : array();
    foreach ($file_usage_list as $entity_type => $entity_ids) {
      $entity_info = entity_get_info($entity_type);
      // The usage table contains usage of every revision. If we are looking
      // for every revision or the entity does not support revisions then
      // every usage is already a match.
      $match_entity_type = $age == FIELD_LOAD_REVISION || !isset($entity_info['entity_keys']['revision']);
      $entities = entity_load_multiple($entity_type, $entity_ids);
      foreach ($entities as $entity) {
        $bundle = $entity->bundle();
        // We need to find file fields for this entity type and bundle.
        if (!isset($file_fields[$entity_type][$bundle])) {
          $file_fields[$entity_type][$bundle] = array();
          // This contains the possible field names.
          $instances = field_info_instances($entity_type, $bundle);
          foreach ($instances as $field_name => $instance) {
            $current_field = field_info_field($field_name);
            // If this is the first time this field type is seen, check
            // whether it references files.
            if (!isset($field_columns[$current_field['type']])) {
              $field_columns[$current_field['type']] = file_field_find_file_reference_column($current_field);
            }
            // If the field type does reference files then record it.
            if ($field_columns[$current_field['type']]) {
              $file_fields[$entity_type][$bundle][$field_name] = $field_columns[$current_field['type']];
            }
          }
        }
        foreach ($file_fields[$entity_type][$bundle] as $field_name => $field_column) {
          $match = $match_entity_type;
          // If we didn't match yet then iterate over the field items to find
          // the referenced file. This will fail if the usage checked is in a
          // non-current revision because field items are from the current
          // revision.
          if (!$match && ($field_items = field_get_items($entity, $field_name))) {
            foreach ($field_items as $item) {
              if ($file->fid == $item[$field_column]) {
                $match = TRUE;
                break;
              }
            }
          }
          if ($match) {
            $references[$file->fid][$age][$field_name][$entity_type][$entity->id()] = $entity;
          }
        }
      }
    }
  }
  $return = $references[$file->fid][$age];
  // Filter the static cache down to the requested entries. The usual static
  // cache is very small so this will be very fast.
  if ($field || $field_type) {
    foreach ($return as $field_name => $data) {
      $current_field = field_info_field($field_name);
      if (($field_type && $current_field['type'] != $field_type) || ($field && $field['id'] != $current_field['id'])) {
        unset($return[$field_name]);
      }
    }
  }
  return $return;
}

/**
 * @} End of "defgroup file-module-api".
 */

/**
 * Implements hook_library_info().
 */
function file_library_info() {
  $libraries['drupal.file'] = array(
    'title' => 'File',
    'version' => VERSION,
    'js' => array(
      drupal_get_path('module', 'file') . '/file.js' => array(),
    ),
    'css' => array(
      drupal_get_path('module', 'file') . '/file.admin.css'
    ),
    'dependencies' => array(
      array('system', 'jquery'),
      array('system', 'drupal'),
      array('system', 'drupalSettings'),
    ),
  );

  return $libraries;
}
