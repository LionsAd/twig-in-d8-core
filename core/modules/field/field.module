<?php
/**
 * @file
 * Attach custom data fields to Drupal entities.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Template\Attribute;

/*
 * Load all public Field API functions. Drupal currently has no
 * mechanism for auto-loading core APIs, so we have to load them on
 * every page request.
 */
require_once DRUPAL_ROOT . '/core/modules/field/field.crud.inc';
require_once DRUPAL_ROOT . '/core/modules/field/field.default.inc';
require_once DRUPAL_ROOT . '/core/modules/field/field.info.inc';
require_once DRUPAL_ROOT . '/core/modules/field/field.multilingual.inc';
require_once DRUPAL_ROOT . '/core/modules/field/field.attach.inc';
require_once DRUPAL_ROOT . '/core/modules/field/field.form.inc';

/**
 * @defgroup field Field API
 * @{
 * Attaches custom data fields to Drupal entities.
 *
 * The Field API allows custom data fields to be attached to Drupal entities and
 * takes care of storing, loading, editing, and rendering field data. Any entity
 * type (node, user, etc.) can use the Field API to make itself "fieldable" and
 * thus allow fields to be attached to it. Other modules can provide a user
 * interface for managing custom fields via a web browser as well as a wide and
 * flexible variety of data type, form element, and display format capabilities.
 *
 * The Field API defines two primary data structures, Field and Instance, and
 * the concept of a Bundle. A Field defines a particular type of data that can
 * be attached to entities. A Field Instance is a Field attached to a single
 * Bundle. A Bundle is a set of fields that are treated as a group by the Field
 * Attach API and is related to a single fieldable entity type.
 *
 * For example, suppose a site administrator wants Article nodes to have a
 * subtitle and photo. Using the Field API or Field UI module, the administrator
 * creates a field named 'subtitle' of type 'text' and a field named 'photo' of
 * type 'image'. The administrator (again, via a UI) creates two Field
 * Instances, one attaching the field 'subtitle' to the 'node' bundle 'article'
 * and one attaching the field 'photo' to the 'node' bundle 'article'. When the
 * node system uses the Field Attach API to load all fields for an Article node,
 * it passes the node's entity type (which is 'node') and content type (which is
 * 'article') as the node's bundle. field_attach_load() then loads the
 * 'subtitle' and 'photo' fields because they are both attached to the 'node'
 * bundle 'article'.
 *
 * - @link field_types Field Types API @endlink: Defines field types, widget
 *   types, and display formatters. Field modules use this API to provide field
 *   types like Text and Node Reference along with the associated form elements
 *   and display formatters.
 *
 * - @link field_crud Field CRUD API @endlink: Create, updates, and deletes
 *   fields, bundles (a.k.a. "content types"), and instances. Modules use this
 *   API, often in hook_install(), to create custom data structures.
 *
 * - @link field_attach Field Attach API @endlink: Connects entity types to the
 *   Field API. Field Attach API functions load, store, generate Form API
 *   structures, display, and perform a variety of other functions for field
 *   data connected to individual entities. Fieldable entity types like node and
 *   user use this API to make themselves fieldable.
 *
 * - @link field_info Field Info API @endlink: Exposes information about all
 *   fields, instances, widgets, and related information defined by or with the
 *   Field API.
 *
 * - @link field_storage Field Storage API @endlink: Provides a pluggable back
 *   -end storage system for actual field data. The default implementation,
 *   field_sql_storage.module, stores field data in the local SQL database.
 *
 * - @link field_purge Field API bulk data deletion @endlink: Cleans up after
 *   bulk deletion operations such as field_delete_field() and
 *   field_delete_instance().
 *
 * - @link field_language Field language API @endlink: Provides native
 *   multilingual support for the Field API.
 */

/**
 * Value for field API indicating a field accepts an unlimited number of values.
 */
const FIELD_CARDINALITY_UNLIMITED = -1;

/**
 * Value for field API indicating a widget doesn't accept default values.
 *
 * @see hook_field_widget_info()
 */
const FIELD_BEHAVIOR_NONE = 0x0001;

/**
 * Value for field API concerning widget default and multiple value settings.
 *
 * @see hook_field_widget_info()
 *
 * When used in a widget default context, indicates the widget accepts default
 * values. When used in a multiple value context for a widget that allows the
 * input of one single field value, indicates that the widget will be repeated
 * for each value input.
 */
const FIELD_BEHAVIOR_DEFAULT = 0x0002;

/**
 * Value for field API indicating a widget can receive several field values.
 *
 * @see hook_field_widget_info()
 */
const FIELD_BEHAVIOR_CUSTOM = 0x0004;

/**
 * Load the most recent version of an entity's field data.
 *
 * @see field_attach_load().
 */
const FIELD_LOAD_CURRENT = 'FIELD_LOAD_CURRENT';

/**
 * Load the version of an entity's field data specified in the entity.
 *
 * @see field_attach_load().
 */
const FIELD_LOAD_REVISION = 'FIELD_LOAD_REVISION';

/**
 * Implements hook_help().
 */
function field_help($path, $arg) {
  switch ($path) {
    case 'admin/help#field':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Field module allows custom data fields to be defined for <em>entity</em> types (entities include content items, comments, user accounts, and taxonomy terms). The Field module takes care of storing, loading, editing, and rendering field data. Most users will not interact with the Field module directly, but will instead use the <a href="@field-ui-help">Field UI module</a> user interface. Module developers can use the Field API to make new entity types "fieldable" and thus allow fields to be attached to them. For more information, see the online handbook entry for <a href="@field">Field module</a>.', array('@field-ui-help' => url('admin/help/field_ui'), '@field' => 'http://drupal.org/documentation/modules/field')) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Enabling field types') . '</dt>';
      $output .= '<dd>' . t('The Field module provides the infrastructure for fields and field attachment; the field types and input widgets themselves are provided by additional modules. Some of the modules are required; the optional modules can be enabled from the <a href="@modules">Modules administration page</a>. Drupal core includes the following field type modules: Number (required), Text (required), List (required), Taxonomy (optional), Image (optional), and File (optional); the required Options module provides input widgets for other field modules. Additional fields and widgets may be provided by contributed modules, which you can find in the <a href="@contrib">contributed module section of Drupal.org</a>. Currently enabled field and input widget modules:', array('@modules' => url('admin/modules'), '@contrib' => 'http://drupal.org/project/modules', '@options' => url('admin/help/options')));

      // Make a list of all widget and field modules currently enabled, in
      // order by displayed module name (module names are not translated).
      $items = array();
      $info = system_get_info('module');
      $modules = array_merge(module_implements('field_info'), module_implements('field_widget_info'));
      $modules = array_unique($modules);
      sort($modules);
      foreach ($modules as $module) {
        $display = $info[$module]['name'];
        if (module_hook($module, 'help')) {
          $items['items'][] = l($display, 'admin/help/' . $module);
        }
        else {
          $items['items'][] = $display;
        }
      }
      $output .= theme('item_list', $items) . '</dd>';
      $output .= '<dt>' . t('Managing field data storage') . '</dt>';
      $output .= '<dd>' . t('Developers of field modules can either use the default <a href="@sql-store">Field SQL Storage module</a> to store data for their fields, or a contributed or custom module developed using the <a href="@storage-api">field storage API</a>.', array('@storage-api' => 'http://api.drupal.org/api/group/field_storage/8', '@sql-store' => url('admin/help/field_sql_storage'))) . '</dd>';
      $output .= '</dl>';
      return $output;
  }
}

/**
 * Implements hook_theme().
 */
function field_theme() {
  return array(
    'field' => array(
      'render element' => 'element',
      'template' => 'field',
    ),
    'field_multiple_value_form' => array(
      'file' => 'field.form.inc',
      'render element' => 'element',
      'template' => 'field-multiple-value-form',
    ),
  );
}

/**
 * Implements hook_cron().
 */
function field_cron() {
  // Refresh the 'active' status of fields.
  field_sync_field_status();

  // Do a pass of purging on deleted Field API data, if any exists.
  $limit = config('field.settings')->get('purge_batch_size');
  field_purge_batch($limit);
}

/**
 * Implements hook_system_info_alter().
 *
 * Goes through a list of all modules that provide a field type and makes them
 * required if there are any active fields of that type.
 */
function field_system_info_alter(&$info, $file, $type) {
  // It is not safe to call field_read_fields() during maintenance mode.
  if ($type == 'module' && module_hook($file->name, 'field_info') && !defined('MAINTENANCE_MODE')) {
    $fields = field_read_fields(array('module' => $file->name), array('include_deleted' => TRUE));
    if ($fields) {
      $info['required'] = TRUE;

      // Provide an explanation message (only mention pending deletions if there
      // remains no actual, non-deleted fields)
      $non_deleted = FALSE;
      foreach ($fields as $field) {
        if (empty($field['deleted'])) {
          $non_deleted = TRUE;
          break;
        }
      }
      if ($non_deleted) {
        if (module_exists('field_ui')) {
          $explanation = t('Field type(s) in use - see <a href="@fields-page">Field list</a>', array('@fields-page' => url('admin/reports/fields')));
        }
        else {
          $explanation = t('Fields type(s) in use');
        }
      }
      else {
        $explanation = t('Fields pending deletion');
      }
      $info['explanation'] = $explanation;
    }
  }
}

/**
 * Implements hook_data_type_info() to register data types for all field types.
 */
function field_data_type_info() {
  $field_types = field_info_field_types();
  $items = array();

  // Expose data types for all the field type items.
  foreach ($field_types as $type_name => $type_info) {
    $data_type = isset($type_info['data_type']) ? $type_info['data_type'] : $type_name . '_field';
    $items[$data_type] = array(
      'label' => t('Field !label item', array('!label' => $type_info['label'])),
      'class' => $type_info['field item class'],
      'list class' => !empty($type_info['field class']) ? $type_info['field class'] : '\Drupal\Core\Entity\Field\Type\Field',
    );
  }
  return $items;
}

/**
 * Implements hook_entity_create().
 */
function field_entity_create(EntityInterface $entity) {
  $info = $entity->entityInfo();
  if (!empty($info['fieldable'])) {
    foreach ($entity->getTranslationLanguages() as $langcode => $language) {
      field_populate_default_values($entity, $langcode);
    }
  }
}

/**
 * Inserts a default value for each entity field not having one.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity for the operation.
 * @param string $langcode
 *   (optional) The field language code to fill-in with the default value.
 *   Defaults to the entity language.
 */
function field_populate_default_values(EntityInterface $entity, $langcode = NULL) {
  $entity_type = $entity->entityType();
  $langcode = $langcode ?: $entity->language()->langcode;
  foreach (field_info_instances($entity_type, $entity->bundle()) as $field_name => $instance) {
    $field = field_info_field($field_name);
    $field_langcode = field_is_translatable($entity_type, $field) ? $langcode : LANGUAGE_NOT_SPECIFIED;
    // We need to preserve existing values.
    if (empty($entity->{$field_name}) || !array_key_exists($field_langcode, $entity->{$field_name})) {
      $items = field_get_default_value($entity, $field, $instance, $field_langcode);
      if (!empty($items)) {
        $entity->{$field_name}[$field_langcode] = $items;
      }
    }
  }
}

/**
 * Implements hook_entity_field_info() to define all configured fields.
 */
function field_entity_field_info($entity_type) {
  $property_info = array();
  $field_types = field_info_field_types();

  foreach (field_info_instances($entity_type) as $bundle_name => $instances) {
    $optional = $bundle_name != $entity_type;

    foreach ($instances as $field_name => $instance) {
      $field = field_info_field($field_name);

      // @todo: Allow for adding field type settings.
      $definition = array(
        'label' => t('Field !name', array('!name' => $field_name)),
        'type' => isset($field_types[$field['type']]['data_type']) ? $field_types[$field['type']]['data_type'] :  $field['type'] . '_field',
        'configurable' => TRUE,
        'translatable' => !empty($field['translatable'])
      );

      if ($optional) {
        $property_info['optional'][$field_name] = $definition;
        $property_info['bundle map'][$bundle_name][] = $field_name;
      }
      else {
        $property_info['definitions'][$field_name] = $definition;
      }
    }
  }

  return $property_info;
}

/**
 * Implements hook_field_widget_info_alter().
 */
function field_field_widget_info_alter(&$info) {
  // Add the Hidden widget to all field types.
  $info['hidden']['field_types'] = array_keys(field_info_field_types());
}

/**
 * Applies language fallback rules to the fields attached to the given entity.
 *
 * Core language fallback rules simply check if fields have a field translation
 * for the requested language code. If so, the requested language is returned,
 * otherwise all the fallback candidates are inspected to see if there is a
 * field translation available in another language.
 * By default this is called by field_field_language_alter(), but this
 * behavior can be disabled by setting the 'field.settings.language_fallback'
 * variable to FALSE.
 *
 * @param $field_langcodes
 *   A reference to an array of language codes keyed by field name.
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity to be displayed.
 * @param $langcode
 *   The language code $entity has to be displayed in.
 */
function field_language_fallback(&$field_langcodes, EntityInterface $entity, $langcode) {
  // Lazily init fallback candidates to avoid unnecessary calls.
  $fallback_candidates = NULL;

  foreach ($field_langcodes as $field_name => $field_langcode) {
    // If the requested language is defined for the current field use it,
    // otherwise search for a fallback value among the fallback candidates.
    if (isset($entity->{$field_name}[$langcode])) {
      $field_langcodes[$field_name] = $langcode;
    }
    elseif (!empty($entity->{$field_name})) {
      if (!isset($fallback_candidates)) {
        require_once DRUPAL_ROOT . '/core/includes/language.inc';
        $fallback_candidates = language_fallback_get_candidates();
      }
      foreach ($fallback_candidates as $fallback_langcode) {
        if (isset($entity->{$field_name}[$fallback_langcode])) {
          $field_langcodes[$field_name] = $fallback_langcode;
          break;
        }
      }
    }
  }
}

/**
 * Implements hook_rebuild().
 */
function field_rebuild() {
  // Refresh the 'active' status of fields.
  field_sync_field_status();
}

/**
 * Implements hook_modules_enabled().
 */
function field_modules_enabled($modules) {
  // Refresh the 'active' status of fields.
  field_sync_field_status();
}

/**
 * Implements hook_modules_disabled().
 */
function field_modules_disabled($modules) {
  // Refresh the 'active' status of fields.
  field_sync_field_status();
}

/**
 * Refreshes the 'active' and 'storage[active]' values for fields.
 */
function field_sync_field_status() {
  $module_handler = Drupal::moduleHandler();
  $state = Drupal::state();

  // Get both deleted and non-deleted field definitions.
  $fields = array();
  foreach (config_get_storage_names_with_prefix('field.field') as $name) {
    $field = Drupal::config($name)->get();
    $fields[$field['uuid']] = $field;
  }
  $deleted_fields = $state->get('field.field.deleted') ?: array();
  $fields += $deleted_fields;

  if (empty($fields)) {
    return;
  }

  // Set the 'module' and 'active' values for the current set of enabled
  // modules.
  $changed = array();
  $modules = $module_handler->getModuleList();
  foreach ($modules as $module => $module_info) {
    // Collect field types and storage backends exposed by the module.
    $field_types = (array) $module_handler->invoke($module, 'field_info');
    $storage_types = (array) $module_handler->invoke($module, 'field_storage_info');

    if ($field_types || $storage_types) {
      foreach ($fields as $uuid => &$field) {
        // Associate field types.
        if (isset($field_types[$field['type']]) && ($field['module'] !== $module || !$field['active'])) {
          $field['module'] = $module;
          $field['active'] = TRUE;
          $changed[$uuid] = $field;
        }
        // Associate storage backends.
        if (isset($storage_types[$field['storage']['type']]) && ($field['storage']['module'] !== $module || !$field['storage']['active'])) {
          $field['storage']['module'] = $module;
          $field['storage']['active'] = TRUE;
          $changed[$uuid] = $field;
        }
      }
    }
  }

  // Set fields with missing field type or storage modules to inactive.
  foreach ($fields as $uuid => &$field) {
    if (!isset($modules[$field['module']]) && $field['active']) {
      $field['active'] = FALSE;
      $changed[$uuid] = $field;
    }
    if (!isset($modules[$field['storage']['module']]) && $field['storage']['active']) {
      $field['storage']['active'] = FALSE;
      $changed[$uuid] = $field;
    }
  }

  // Store the updated field definitions.
  foreach ($changed as $uuid => $field) {
    if (!empty($field['deleted'])) {
      $deleted_fields[$uuid] = $field;
    }
    else {
      Drupal::config('field.field.' . $field['id'])
        ->set('module', $field['module'])
        ->set('active', $field['active'])
        ->set('storage.module', $field['storage']['module'])
        ->set('storage.active', $field['storage']['active'])
        ->save();
    }
  }
  $state->set('field.field.deleted', $deleted_fields);

  field_cache_clear();
}

/**
 * Helper function to get the default value for a field on an entity.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity for the operation.
 * @param $field
 *   The field structure.
 * @param $instance
 *   The instance structure.
 * @param $langcode
 *   The field language to fill-in with the default value.
 */
function field_get_default_value(EntityInterface $entity, $field, $instance, $langcode = NULL) {
  $items = array();
  if (!empty($instance['default_value_function'])) {
    $function = $instance['default_value_function'];
    $items = $function($entity, $field, $instance, $langcode);
  }
  elseif (!empty($instance['default_value'])) {
    $items = $instance['default_value'];
  }
  return $items;
}

/**
 * Filters out empty field values.
 *
 * @param $field
 *   The field definition.
 * @param $items
 *   The field values to filter.
 *
 * @return
 *   The array of items without empty field values. The function also renumbers
 *   the array keys to ensure sequential deltas.
 */
function _field_filter_items($field, $items) {
  $function = $field['module'] . '_field_is_empty';
  foreach ((array) $items as $delta => $item) {
    // Explicitly break if the function is undefined.
    if ($function($item, $field)) {
      unset($items[$delta]);
    }
  }
  return array_values($items);
}

/**
 * Sorts items in a field according to user drag-and-drop reordering.
 *
 * @param $field
 *   The field definition.
 * @param $items
 *   The field values to sort.
 *
 * @return
 *   The sorted array of field items.
 */
function _field_sort_items($field, $items) {
  if (($field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED) && isset($items[0]['_weight'])) {
    usort($items, '_field_sort_items_helper');
    foreach ($items as $delta => $item) {
      if (is_array($items[$delta])) {
        unset($items[$delta]['_weight']);
      }
    }
  }
  return $items;
}

/**
 * Callback for usort() within _field_sort_items().
 *
 * Copied form element_sort(), which acts on #weight keys.
 */
function _field_sort_items_helper($a, $b) {
  $a_weight = (is_array($a) ? $a['_weight'] : 0);
  $b_weight = (is_array($b) ? $b['_weight'] : 0);
  return $a_weight - $b_weight;
}

/**
 * Callback for usort() within theme_field_multiple_value_form().
 *
 * Sorts using ['_weight']['#value']
 */
function _field_sort_items_value_helper($a, $b) {
  $a_weight = (is_array($a) && isset($a['_weight']['#value']) ? $a['_weight']['#value'] : 0);
  $b_weight = (is_array($b) && isset($b['_weight']['#value']) ? $b['_weight']['#value'] : 0);
  return $a_weight - $b_weight;
}

/**
 * Gets or sets administratively defined bundle settings.
 *
 * @param string $entity_type
 *   The type of $entity; e.g., 'node' or 'user'.
 * @param string $bundle
 *   The bundle name.
 * @param array|null $settings
 *   (optional) The settings to store, an associative array with the following
 *   elements:
 *   - view_modes: An associative array keyed by view mode, with the following
 *     key/value pairs:
 *     - custom_settings: Boolean specifying whether the view mode uses a
 *       dedicated set of display options (TRUE), or the 'default' options
 *       (FALSE). Defaults to FALSE.
 *   - extra_fields: An associative array containing the form and display
 *     settings for extra fields (also known as pseudo-fields):
 *     - form: An associative array whose keys are the names of extra fields,
 *       and whose values are associative arrays with the following elements:
 *       - weight: The weight of the extra field, determining its position on an
 *         entity form.
 *     - display: An associative array whose keys are the names of extra fields,
 *       and whose values are associative arrays keyed by the name of view
 *       modes. This array must include an item for the 'default' view mode.
 *       Each view mode sub-array contains the following elements:
 *       - weight: The weight of the extra field, determining its position when
 *         an entity is viewed.
 *       - visible: TRUE if the extra field is visible, FALSE otherwise.
 *
 * @return array|null
 *   If no $settings are passed, the current settings are returned.
 */
function field_bundle_settings($entity_type, $bundle, $settings = NULL) {
  if (isset($settings)) {
    variable_set('field_bundle_settings_' . $entity_type . '__' . $bundle, $settings);
    field_info_cache_clear();
  }
  else {
    $settings = variable_get('field_bundle_settings_' . $entity_type . '__' . $bundle, array());
    $settings += array(
      'view_modes' => array(),
      'extra_fields' => array(),
    );
    $settings['extra_fields'] += array(
      'form' => array(),
    );

    return $settings;
  }
}

/**
 * Returns view mode settings in a given bundle.
 *
 * @param $entity_type
 *   The type of entity; e.g. 'node' or 'user'.
 * @param $bundle
 *   The bundle name to return view mode settings for.
 *
 * @return
 *   An array keyed by view mode, with the following key/value pairs:
 *   - custom_settings: Boolean specifying whether the view mode uses a
 *     dedicated set of display options (TRUE), or the 'default' options
 *     (FALSE). Defaults to FALSE.
 */
function field_view_mode_settings($entity_type, $bundle) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (!isset($cache[$entity_type][$bundle])) {
    $bundle_settings = field_bundle_settings($entity_type, $bundle);
    $settings = $bundle_settings['view_modes'];
    // Include view modes for which nothing has been stored yet, but whose
    // definition in hook_entity_info_alter() specify they should use custom
    // settings by default.
    $view_modes = entity_get_view_modes($entity_type);
    foreach ($view_modes as $view_mode => $view_mode_info) {
      if (!isset($settings[$view_mode]['custom_settings']) && $view_mode_info['custom_settings']) {
        $settings[$view_mode]['custom_settings'] = TRUE;
      }
    }
    $cache[$entity_type][$bundle] = $settings;
  }

  return $cache[$entity_type][$bundle];
}

/**
 * Pre-render callback: Adjusts weights and visibility of non-field elements.
 */
function _field_extra_fields_pre_render($elements) {
  $entity_type = $elements['#entity_type'];
  $bundle = $elements['#bundle'];

  $extra_fields = field_info_extra_fields($entity_type, $bundle, 'form');
  foreach ($extra_fields as $name => $settings) {
    if (isset($elements[$name])) {
      $elements[$name]['#weight'] = $settings['weight'];
    }
  }

  return $elements;
}

/**
 * Clears the field info and field data caches.
 */
function field_cache_clear() {
  cache('field')->deleteAll();
  field_info_cache_clear();
}

/**
 * Filters an HTML string to prevent cross-site-scripting (XSS) vulnerabilities.
 *
 * Like filter_xss_admin(), but with a shorter list of allowed tags.
 *
 * Used for items entered by administrators, like field descriptions, allowed
 * values, where some (mainly inline) mark-up may be desired (so
 * drupal_htmlspecialchars() is not acceptable).
 *
 * @param $string
 *   The string with raw HTML in it.
 *
 * @return
 *   An XSS safe version of $string, or an empty string if $string is not valid
 *   UTF-8.
 */
function field_filter_xss($string) {
  return filter_xss($string, _field_filter_xss_allowed_tags());
}

/**
 * Returns a list of tags allowed by field_filter_xss().
 */
function _field_filter_xss_allowed_tags() {
  return array('a', 'b', 'big',  'code', 'del', 'em', 'i', 'ins',  'pre', 'q', 'small', 'span', 'strong', 'sub', 'sup', 'tt', 'ol', 'ul', 'li', 'p', 'br', 'img');
}

/**
 * Returns a human-readable list of allowed tags for display in help texts.
 */
function _field_filter_xss_display_allowed_tags() {
  return '<' . implode('> <', _field_filter_xss_allowed_tags()) . '>';
}

/**
 * Returns a renderable array for a single field value.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity containing the field to display. Must at least contain the ID
 *   key and the field data to display.
 * @param $field_name
 *   The name of the field to display.
 * @param $item
 *   The field value to display, as found in
 *   $entity->field_name[$langcode][$delta].
 * @param $display
 *   Can be either the name of a view mode, or an array of display settings. See
 *   field_view_field() for more information.
 * @param $langcode
 *   (Optional) The language of the value in $item. If not provided, the current
 *   language will be assumed.
 *
 * @return
 *   A renderable array for the field value.
 */
function field_view_value(EntityInterface $entity, $field_name, $item, $display = array(), $langcode = NULL) {
  $output = array();

  if ($field = field_info_field($field_name)) {
    // Determine the langcode that will be used by language fallback.
    $langcode = field_language($entity, $field_name, $langcode);

    // Push the item as the single value for the field, and defer to
    // field_view_field() to build the render array for the whole field.
    $clone = clone $entity;
    $clone->{$field_name}[$langcode] = array($item);
    $elements = field_view_field($clone, $field_name, $display, $langcode);

    // Extract the part of the render array we need.
    $output = isset($elements[0]) ? $elements[0] : array();
    if (isset($elements['#access'])) {
      $output['#access'] = $elements['#access'];
    }
  }

  return $output;
}

/**
 * Returns a renderable array for the value of a single field in an entity.
 *
 * The resulting output is a fully themed field with label and multiple values.
 *
 * This function can be used by third-party modules that need to output an
 * isolated field.
 * - Do not use inside node (or other entities) templates, use
 *   render($content[FIELD_NAME]) instead.
 * - Do not use to display all fields in an entity, use
 *   field_attach_prepare_view() and field_attach_view() instead.
 * - The field_view_value() function can be used to output a single formatted
 *   field value, without label or wrapping field markup.
 *
 * The function takes care of invoking the prepare_view steps. It also respects
 * field access permissions.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity containing the field to display.
 * @param $field_name
 *   The name of the field to display.
 * @param $display_options
 *   Can be either:
 *   - The name of a view mode. The field will be displayed according to the
 *     display settings specified for this view mode in the $instance
 *     definition for the field in the entity's bundle. If no display settings
 *     are found for the view mode, the settings for the 'default' view mode
 *     will be used.
 *   - An array of display options. The following key/value pairs are allowed:
 *     - label: (string) Position of the label. The default 'field' theme
 *       implementation supports the values 'inline', 'above' and 'hidden'.
 *       Defaults to 'above'.
 *     - type: (string) The formatter to use. Defaults to the
 *       'default_formatter' for the field type, specified in hook_field_info().
 *       The default formatter will also be used if the requested formatter is
 *       not available.
 *     - settings: (array) Settings specific to the formatter. Defaults to the
 *       formatter's default settings, specified in hook_field_formatter_info().
 *     - weight: (float) The weight to assign to the renderable element.
 *       Defaults to 0.
 * @param $langcode
 *   (Optional) The language code the field values are to be shown in. The
 *   site's current language fallback logic will be applied when no values are
 *   available for the given language code. If no language code is provided the
 *   current language will be used.
 *
 * @return
 *   A renderable array for the field value.
 *
 * @see field_view_value()
 */
function field_view_field(EntityInterface $entity, $field_name, $display_options = array(), $langcode = NULL) {
  $output = array();
  $bundle = $entity->bundle();

  // Return nothing if the field doesn't exist.
  $instance = field_info_instance($entity->entityType(), $field_name, $bundle);
  if (!$instance) {
    return $output;
  }

  // Get the formatter object.
  if (is_string($display_options)) {
    $view_mode = $display_options;
    $formatter = entity_get_render_display($entity, $view_mode)->getFormatter($field_name);
  }
  else {
    $view_mode = '_custom';
    // hook_field_attach_display_alter() needs to receive the 'prepared'
    // $display_options, so we cannot let preparation happen internally.
    $field = field_info_field($field_name);
    $formatter_manager = drupal_container()->get('plugin.manager.field.formatter');
    $display_options = $formatter_manager->prepareConfiguration($field['type'], $display_options);
    $formatter = $formatter_manager->getInstance(array(
      'instance' => $instance,
      'view_mode' => $view_mode,
      'prepare' => FALSE,
      'configuration' => $display_options,
    ));
  }

  if ($formatter) {
    $display_langcode = field_language($entity, $field_name, $langcode);
    $items = array();
    if (isset($entity->{$field_name}[$display_langcode])) {
      $items = $entity->{$field_name}[$display_langcode];
    }

    // Invoke prepare_view steps if needed.
    if (empty($entity->_field_view_prepared)) {
      $id = $entity->id();

      // First let the field types do their preparation.
      $options = array('field_name' => $field_name, 'langcode' => $display_langcode);
      $null = NULL;
      _field_invoke_multiple('prepare_view', $entity->entityType(), array($id => $entity), $null, $null, $options);

      // Then let the formatter do its own specific massaging.
      $items_multi = array($id => array());
      if (isset($entity->{$field_name}[$display_langcode])) {
        $items_multi[$id] = $entity->{$field_name}[$display_langcode];
      }
      $formatter->prepareView(array($id => $entity), $display_langcode, $items_multi);
      $items = $items_multi[$id];
    }

    // Build the renderable array.
    $result = $formatter->view($entity, $display_langcode, $items);

    // Invoke hook_field_attach_view_alter() to let other modules alter the
    // renderable array, as in a full field_attach_view() execution.
    $context = array(
      'entity' => $entity,
      'view_mode' => $view_mode,
      'display_options' => $display_options,
    );
    drupal_alter('field_attach_view', $result, $context);

    if (isset($result[$field_name])) {
      $output = $result[$field_name];
    }
  }

  return $output;
}

/**
 * Returns the field items in the language they currently would be displayed.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity containing the data to be displayed.
 * @param $field_name
 *   The field to be displayed.
 * @param $langcode
 *   (optional) The language code $entity->{$field_name} has to be displayed in.
 *   Defaults to the current language.
 *
 * @return
 *   An array with available field items keyed by delta.
 */
function field_get_items(EntityInterface $entity, $field_name, $langcode = NULL) {
  $entity = $entity->getBCEntity();
  $langcode = field_language($entity, $field_name, $langcode);
  return isset($entity->{$field_name}[$langcode]) ? $entity->{$field_name}[$langcode] : array();
}

/**
 * Determines whether a field has any data.
 *
 * @param $field
 *   A field structure.
 *
 * @return
 *   TRUE if the field has data for any entity; FALSE otherwise.
 */
function field_has_data($field) {
  $columns = array_keys($field['columns']);
  $factory = Drupal::service('entity.query');
  foreach ($field['bundles'] as $entity_type => $bundle) {
    // Entity Query throws an exception if there is no base table.
    $entity_info = entity_get_info($entity_type);
    if (!isset($entity_info['base_table'])) {
      continue;
    }
    $query = $factory->get($entity_type);
    $group = $query->orConditionGroup();
    foreach ($columns as $column) {
      $group->exists($field['field_name'] . '.' . $column);
    }
    $result = $query
      ->condition($group)
      ->count()
      ->accessCheck(FALSE)
      ->range(0, 1)
      ->execute();
    if ($result) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Determines whether the user has access to a given field.
 *
 * @param string $op
 *   The operation to be performed. Possible values:
 *   - edit
 *   - view
 * @param array $field
 *   The full field structure array for the field on which the operation is to
 *   be performed. See field_info_field().
 * @param $entity_type
 *   The type of $entity; for example, 'node' or 'user'.
 * @param $entity
 *   (optional) The entity for the operation.
 * @param $account
 *   (optional) The account to check, if not given use currently logged in user.
 *
 * @return
 *   TRUE if the operation is allowed; FALSE if the operation is denied.
 */
function field_access($op, $field, $entity_type, $entity = NULL, $account = NULL) {
  global $user;

  if (!isset($account)) {
    $account = $user;
  }

  foreach (module_implements('field_access') as $module) {
    $function = $module . '_field_access';
    $access = $function($op, $field, $entity_type, $entity, $account);
    if ($access === FALSE) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Extracts the bundle name from a bundle object.
 *
 * @param $entity_type
 *   The type of $entity; e.g., 'node' or 'user'.
 * @param $bundle
 *   The bundle object (or string if bundles for this entity type do not exist
 *   as standalone objects).
 *
 * @return
 *   The bundle name.
 */
function field_extract_bundle($entity_type, $bundle) {
  if (is_string($bundle)) {
    return $bundle;
  }

  $info = entity_get_info($entity_type);
  if (is_object($bundle) && isset($info['bundle_keys']['bundle']) && isset($bundle->{$info['bundle_keys']['bundle']})) {
    return $bundle->{$info['bundle_keys']['bundle']};
  }
}

/**
 * Implements hook_page_build().
 */
function field_page_build(&$page) {
  $path = drupal_get_path('module', 'field');
  $page['#attached']['css'][$path . '/theme/field.css'] = array('every_page' => TRUE);
}

 /**
  * Prepares variables for field templates.
  *
  * Default template: field.html.twig.
  *
  * To override output, copy the "field.html.twig" from the templates directory
  * to your theme's directory and customize it, just like customizing other
  * Drupal templates such as page.html.twig or node.html.twig.
  *
  * For example, for a field named 'body' displayed on the 'article'
  * content type, any of the following templates will override this default
  * implementation. The first of these templates that exists is used:
  * - field--body--article.html.twig
  * - field--article.html.twig
  * - field--body.html.twig
  * - field.html.twig
  *
  * @param array $variables
  *   An associative array containing:
  *   - element: A render element representing the field.
  *   - attributes: A string containing the attributes for the wrapping div.
  *   - title_attributes: A string containing the attributes for the title.
  *   - content_attributes: A string containing the attributes for the content's
  *     div.
  */
function template_preprocess_field(&$variables, $hook) {
  $element = $variables['element'];

  // There's some overhead in calling check_plain() so only call it if the label
  // variable is being displayed. Otherwise, set it to NULL to avoid PHP
  // warnings if a theme implementation accesses the variable even when it's
  // supposed to be hidden. If a theme implementation needs to print a hidden
  // label, it needs to supply a preprocess function that sets it to the
  // sanitized element title or whatever else is wanted in its place.
  $variables['label_hidden'] = ($element['#label_display'] == 'hidden');
  $variables['label'] = $variables['label_hidden'] ? NULL : check_plain($element['#title']);

  // We want other preprocess functions and the theme implementation to have
  // fast access to the field item render arrays. The item render array keys
  // (deltas) should always be a subset of the keys in #items, and looping on
  // those keys is faster than calling element_children() or looping on all keys
  // within $element, since that requires traversal of all element properties.
  $variables['items'] = array();
  foreach ($element['#items'] as $delta => $item) {
    if (!empty($element[$delta])) {
      $variables['items'][$delta] = $element[$delta];
    }
  }

  // Add default CSS classes. Since there can be many fields rendered on a page,
  // save some overhead by calling strtr() directly instead of
  // drupal_html_class().
  $variables['field_name_css'] = strtr($element['#field_name'], '_', '-');
  $variables['field_type_css'] = strtr($element['#field_type'], '_', '-');
  $variables['attributes']['class'] = array(
    'field',
    'field-name-' . $variables['field_name_css'],
    'field-type-' . $variables['field_type_css'],
    'field-label-' . $element['#label_display'],
  );
  // Add a "clearfix" class to the wrapper since we float the label and the
  // field items in field.css if the label is inline.
  if ($element['#label_display'] == 'inline') {
    $variables['attributes']['class'][] = 'clearfix';
  }

  // Add specific suggestions that can override the default implementation.
  $variables['theme_hook_suggestions'] = array(
    'field__' . $element['#field_type'],
    'field__' . $element['#field_name'],
    'field__' . $element['#bundle'],
    'field__' . $element['#field_name'] . '__' . $element['#bundle'],
  );
}

/**
 * Theme process function for theme_field() and field.tpl.php.
 *
 * @see theme_field()
 * @see field.tpl.php
 */
function template_process_field(&$variables, $hook) {
  static $default_attributes;
  // The default theme implementation is a function, so template_process() does
  // not automatically run, so we need to flatten the classes and attributes
  // here. For best performance, only instantiate Drupal\Core\Template\Attribute
  // when needed, and note that template_preprocess_field() does not initialize
  // the *_attributes variables.
  if (!isset($default_attributes)) {
    $default_attributes = new Attribute;
  }
  $variables['attributes'] = isset($variables['attributes']) ? new Attribute($variables['attributes']) : clone $default_attributes;
  $variables['title_attributes'] = isset($variables['title_attributes']) ? new Attribute($variables['title_attributes']) : clone($default_attributes);
  $variables['content_attributes'] = isset($variables['content_attributes']) ? new Attribute($variables['content_attributes']) : clone($default_attributes);
  foreach ($variables['items'] as $delta => $item) {
    $variables['item_attributes'][$delta] = isset($variables['item_attributes'][$delta]) ? new Attribute($variables['item_attributes'][$delta]) : clone($default_attributes);
  }
}

/**
 * @} End of "defgroup field".
 */

/**
 * Assembles a partial entity structure with initial IDs.
 *
 * @param stdClass $ids
 *   An object with the properties entity_type (required), entity_id (required),
 *   revision_id (optional) and bundle (optional).
 *
 * @return \Drupal\Core\Entity\EntityInterface
 *   An entity, initialized with the provided IDs.
 */
function _field_create_entity_from_ids($ids) {
  $id_properties = array();
  $info = entity_get_info($ids->entity_type);
  if (isset($info['entity_keys']['id'])) {
    $id_properties[$info['entity_keys']['id']] = $ids->entity_id;
  }
  if (!empty($info['entity_keys']['revision']) && isset($ids->revision_id)) {
    $id_properties[$info['entity_keys']['revision']] = $ids->revision_id;
  }
  if (!empty($info['entity_keys']['bundle']) && isset($ids->bundle)) {
    $id_properties[$info['entity_keys']['bundle']] = $ids->bundle;
  }
  return entity_create($ids->entity_type, $id_properties);
}

/**
 * A list of columns that can not be used as field type columns.
 *
 * @return array
 */
function field_reserved_columns() {
  return array('deleted');
}

/**
 * Implements hook_hook_info().
 */
function field_hook_info() {
  $hooks['field_views_data'] = array(
    'group' => 'views',
  );
  $hooks['field_views_data_alter'] = array(
    'group' => 'views',
  );

  return $hooks;
}
